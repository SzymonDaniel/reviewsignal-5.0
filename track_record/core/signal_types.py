"""
Signal Type Definitions for ReviewSignal Track Record System

Defines all signal types, statuses, and data structures used
throughout the track record and backtesting system.
"""

from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List
from uuid import uuid4
import json


class SignalType(Enum):
    """Types of trading signals generated by ReviewSignal."""
    BUY = "BUY"                      # Strong positive sentiment, expect price increase
    SELL = "SELL"                    # Strong negative sentiment, expect price decrease
    HOLD = "HOLD"                    # Neutral sentiment, no action recommended
    STRONG_BUY = "STRONG_BUY"        # Very strong positive, high confidence
    STRONG_SELL = "STRONG_SELL"      # Very strong negative, high confidence
    ACCUMULATE = "ACCUMULATE"        # Gradually increase position
    REDUCE = "REDUCE"                # Gradually decrease position
    
    @classmethod
    def from_sentiment(cls, sentiment_score: float, confidence: float) -> 'SignalType':
        """
        Derive signal type from sentiment score and confidence.
        
        Args:
            sentiment_score: Normalized sentiment (-1 to 1)
            confidence: Model confidence (0 to 1)
            
        Returns:
            Appropriate SignalType based on thresholds
        """
        if confidence < 0.5:
            return cls.HOLD
        
        if sentiment_score >= 0.7 and confidence >= 0.8:
            return cls.STRONG_BUY
        elif sentiment_score >= 0.3:
            return cls.BUY
        elif sentiment_score <= -0.7 and confidence >= 0.8:
            return cls.STRONG_SELL
        elif sentiment_score <= -0.3:
            return cls.SELL
        elif sentiment_score > 0:
            return cls.ACCUMULATE
        elif sentiment_score < 0:
            return cls.REDUCE
        else:
            return cls.HOLD


class SignalStatus(Enum):
    """Lifecycle status of a signal."""
    PENDING = "PENDING"              # Signal generated, awaiting outcome
    ACTIVE = "ACTIVE"                # Signal is currently active
    CLOSED_PROFIT = "CLOSED_PROFIT"  # Signal closed with profit
    CLOSED_LOSS = "CLOSED_LOSS"      # Signal closed with loss
    CLOSED_NEUTRAL = "CLOSED_NEUTRAL"  # Signal closed at breakeven
    EXPIRED = "EXPIRED"              # Signal expired without action
    CANCELLED = "CANCELLED"          # Signal was cancelled


class SignalSource(Enum):
    """Source of the signal generation."""
    SENTIMENT_MODEL = "SENTIMENT_MODEL"      # Primary NLP sentiment model
    ANOMALY_DETECTION = "ANOMALY_DETECTION"  # Anomaly detection system
    ECHO_ENGINE = "ECHO_ENGINE"              # Quantum-inspired echo engine
    COMPETITOR_INTEL = "COMPETITOR_INTEL"    # Competitor intelligence
    TREND_FORECAST = "TREND_FORECAST"        # Time series forecasting
    ENSEMBLE = "ENSEMBLE"                    # Ensemble of multiple models
    MANUAL = "MANUAL"                        # Manual analyst override


@dataclass
class Signal:
    """
    Represents a trading signal generated by ReviewSignal.
    
    This is the core data structure for tracking all signals,
    their outcomes, and associated metadata.
    """
    # Identification
    signal_id: str = field(default_factory=lambda: str(uuid4()))
    
    # Timing
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    expires_at: Optional[datetime] = None
    closed_at: Optional[datetime] = None
    
    # Signal Details
    signal_type: SignalType = SignalType.HOLD
    status: SignalStatus = SignalStatus.PENDING
    source: SignalSource = SignalSource.SENTIMENT_MODEL
    
    # Target
    brand: str = ""
    ticker: str = ""
    location_ids: List[str] = field(default_factory=list)
    
    # Confidence & Scores
    confidence: float = 0.0          # Model confidence (0-1)
    sentiment_score: float = 0.0     # Normalized sentiment (-1 to 1)
    sentiment_magnitude: float = 0.0  # Sentiment strength (0-1)
    review_velocity: float = 0.0     # Review change rate
    anomaly_score: float = 0.0       # Anomaly detection score
    echo_coefficient: float = 0.0    # Echo engine butterfly coefficient
    
    # Price Data
    price_at_signal: float = 0.0     # Stock price when signal generated
    target_price: Optional[float] = None  # Expected target price
    stop_loss: Optional[float] = None     # Stop loss level
    price_at_close: Optional[float] = None  # Price when signal closed
    
    # Performance
    return_pct: Optional[float] = None     # Percentage return
    return_abs: Optional[float] = None     # Absolute return ($)
    holding_period_days: Optional[int] = None  # Days held
    
    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)
    tags: List[str] = field(default_factory=list)
    notes: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for storage/serialization."""
        return {
            "signal_id": self.signal_id,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
            "closed_at": self.closed_at.isoformat() if self.closed_at else None,
            "signal_type": self.signal_type.value,
            "status": self.status.value,
            "source": self.source.value,
            "brand": self.brand,
            "ticker": self.ticker,
            "location_ids": self.location_ids,
            "confidence": self.confidence,
            "sentiment_score": self.sentiment_score,
            "sentiment_magnitude": self.sentiment_magnitude,
            "review_velocity": self.review_velocity,
            "anomaly_score": self.anomaly_score,
            "echo_coefficient": self.echo_coefficient,
            "price_at_signal": self.price_at_signal,
            "target_price": self.target_price,
            "stop_loss": self.stop_loss,
            "price_at_close": self.price_at_close,
            "return_pct": self.return_pct,
            "return_abs": self.return_abs,
            "holding_period_days": self.holding_period_days,
            "metadata": self.metadata,
            "tags": self.tags,
            "notes": self.notes,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Signal':
        """Create Signal from dictionary."""
        signal = cls()
        signal.signal_id = data.get("signal_id", signal.signal_id)
        signal.created_at = datetime.fromisoformat(data["created_at"]) if "created_at" in data else signal.created_at
        signal.updated_at = datetime.fromisoformat(data["updated_at"]) if "updated_at" in data else signal.updated_at
        signal.expires_at = datetime.fromisoformat(data["expires_at"]) if data.get("expires_at") else None
        signal.closed_at = datetime.fromisoformat(data["closed_at"]) if data.get("closed_at") else None
        signal.signal_type = SignalType(data.get("signal_type", "HOLD"))
        signal.status = SignalStatus(data.get("status", "PENDING"))
        signal.source = SignalSource(data.get("source", "SENTIMENT_MODEL"))
        signal.brand = data.get("brand", "")
        signal.ticker = data.get("ticker", "")
        signal.location_ids = data.get("location_ids", [])
        signal.confidence = data.get("confidence", 0.0)
        signal.sentiment_score = data.get("sentiment_score", 0.0)
        signal.sentiment_magnitude = data.get("sentiment_magnitude", 0.0)
        signal.review_velocity = data.get("review_velocity", 0.0)
        signal.anomaly_score = data.get("anomaly_score", 0.0)
        signal.echo_coefficient = data.get("echo_coefficient", 0.0)
        signal.price_at_signal = data.get("price_at_signal", 0.0)
        signal.target_price = data.get("target_price")
        signal.stop_loss = data.get("stop_loss")
        signal.price_at_close = data.get("price_at_close")
        signal.return_pct = data.get("return_pct")
        signal.return_abs = data.get("return_abs")
        signal.holding_period_days = data.get("holding_period_days")
        signal.metadata = data.get("metadata", {})
        signal.tags = data.get("tags", [])
        signal.notes = data.get("notes", "")
        return signal
    
    def to_json(self) -> str:
        """Convert signal to JSON string."""
        return json.dumps(self.to_dict(), indent=2)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'Signal':
        """Create Signal from JSON string."""
        return cls.from_dict(json.loads(json_str))
    
    def close(self, price: float, status: Optional[SignalStatus] = None) -> None:
        """
        Close the signal with final price and calculate returns.
        
        Args:
            price: Closing price
            status: Optional status override (auto-calculated if None)
        """
        self.price_at_close = price
        self.closed_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
        
        # Calculate returns
        if self.price_at_signal > 0:
            if self.signal_type in [SignalType.BUY, SignalType.STRONG_BUY, SignalType.ACCUMULATE]:
                self.return_pct = ((price - self.price_at_signal) / self.price_at_signal) * 100
            else:  # SELL signals profit from price decrease
                self.return_pct = ((self.price_at_signal - price) / self.price_at_signal) * 100
            
            self.return_abs = self.return_pct * self.price_at_signal / 100
        
        # Calculate holding period
        if self.created_at:
            self.holding_period_days = (self.closed_at - self.created_at).days
        
        # Determine status
        if status:
            self.status = status
        elif self.return_pct is not None:
            if self.return_pct > 0.5:  # > 0.5% profit
                self.status = SignalStatus.CLOSED_PROFIT
            elif self.return_pct < -0.5:  # > 0.5% loss
                self.status = SignalStatus.CLOSED_LOSS
            else:
                self.status = SignalStatus.CLOSED_NEUTRAL
    
    @property
    def is_active(self) -> bool:
        """Check if signal is currently active."""
        return self.status in [SignalStatus.PENDING, SignalStatus.ACTIVE]
    
    @property
    def is_closed(self) -> bool:
        """Check if signal has been closed."""
        return self.status in [
            SignalStatus.CLOSED_PROFIT,
            SignalStatus.CLOSED_LOSS,
            SignalStatus.CLOSED_NEUTRAL,
            SignalStatus.EXPIRED,
            SignalStatus.CANCELLED,
        ]
    
    @property
    def is_profitable(self) -> bool:
        """Check if closed signal was profitable."""
        return self.status == SignalStatus.CLOSED_PROFIT


@dataclass
class SignalBatch:
    """
    A batch of signals for bulk operations.
    """
    batch_id: str = field(default_factory=lambda: str(uuid4()))
    created_at: datetime = field(default_factory=datetime.utcnow)
    signals: List[Signal] = field(default_factory=list)
    
    def add(self, signal: Signal) -> None:
        """Add a signal to the batch."""
        self.signals.append(signal)
    
    def __len__(self) -> int:
        return len(self.signals)
    
    def __iter__(self):
        return iter(self.signals)
