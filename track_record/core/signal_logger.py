"""
Signal Logger - Core component for tracking all trading signals

This module logs every BUY/SELL/HOLD signal generated by ReviewSignal,
including metadata, confidence scores, and source data.

Usage:
    logger = SignalLogger(db_url="postgresql://...")
    signal = logger.log_signal(
        symbol="MCD",
        signal_type=SignalType.BUY,
        confidence=0.85,
        source_data={...}
    )
"""

import uuid
from datetime import datetime, timezone
from enum import Enum
from typing import Optional, Dict, Any, List
from dataclasses import dataclass, field
import json
from loguru import logger


class SignalType(Enum):
    """Trading signal types"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    STRONG_BUY = "STRONG_BUY"
    STRONG_SELL = "STRONG_SELL"


class SignalSource(Enum):
    """Source of the signal"""
    SENTIMENT_SPIKE = "sentiment_spike"
    RATING_CHANGE = "rating_change"
    REVIEW_VOLUME = "review_volume"
    COMPETITOR_SHIFT = "competitor_shift"
    ECHO_ENGINE = "echo_engine"  # Quantum-inspired butterfly effect
    ANOMALY_DETECTION = "anomaly_detection"
    PREDICTIVE_MODEL = "predictive_model"


@dataclass
class Signal:
    """
    Trading Signal Data Model
    
    Represents a single trading signal with all metadata needed
    for track record and compliance.
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    
    # Core signal data
    symbol: str = ""  # Stock ticker (e.g., "MCD", "SBUX")
    brand: str = ""   # Brand name (e.g., "McDonald's")
    signal_type: SignalType = SignalType.HOLD
    
    # Confidence & strength
    confidence: float = 0.0  # 0.0 - 1.0
    strength: float = 0.0    # Signal strength multiplier
    
    # Timing
    generated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    valid_until: Optional[datetime] = None  # Signal expiration
    
    # Price targets
    entry_price: Optional[float] = None
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    
    # Source & reasoning
    source: SignalSource = SignalSource.SENTIMENT_SPIKE
    reasoning: str = ""
    source_data: Dict[str, Any] = field(default_factory=dict)
    
    # Tracking
    actual_price_at_signal: Optional[float] = None
    outcome_price: Optional[float] = None
    outcome_date: Optional[datetime] = None
    outcome_return: Optional[float] = None
    is_winner: Optional[bool] = None
    
    # Metadata
    locations_analyzed: int = 0
    reviews_analyzed: int = 0
    sentiment_score: Optional[float] = None
    sentiment_change: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for storage"""
        return {
            "id": self.id,
            "symbol": self.symbol,
            "brand": self.brand,
            "signal_type": self.signal_type.value,
            "confidence": self.confidence,
            "strength": self.strength,
            "generated_at": self.generated_at.isoformat(),
            "valid_until": self.valid_until.isoformat() if self.valid_until else None,
            "entry_price": self.entry_price,
            "target_price": self.target_price,
            "stop_loss": self.stop_loss,
            "source": self.source.value,
            "reasoning": self.reasoning,
            "source_data": self.source_data,
            "actual_price_at_signal": self.actual_price_at_signal,
            "outcome_price": self.outcome_price,
            "outcome_date": self.outcome_date.isoformat() if self.outcome_date else None,
            "outcome_return": self.outcome_return,
            "is_winner": self.is_winner,
            "locations_analyzed": self.locations_analyzed,
            "reviews_analyzed": self.reviews_analyzed,
            "sentiment_score": self.sentiment_score,
            "sentiment_change": self.sentiment_change,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Signal":
        """Create signal from dictionary"""
        return cls(
            id=data.get("id", str(uuid.uuid4())),
            symbol=data.get("symbol", ""),
            brand=data.get("brand", ""),
            signal_type=SignalType(data.get("signal_type", "HOLD")),
            confidence=data.get("confidence", 0.0),
            strength=data.get("strength", 0.0),
            generated_at=datetime.fromisoformat(data["generated_at"]) if data.get("generated_at") else datetime.now(timezone.utc),
            valid_until=datetime.fromisoformat(data["valid_until"]) if data.get("valid_until") else None,
            entry_price=data.get("entry_price"),
            target_price=data.get("target_price"),
            stop_loss=data.get("stop_loss"),
            source=SignalSource(data.get("source", "sentiment_spike")),
            reasoning=data.get("reasoning", ""),
            source_data=data.get("source_data", {}),
            actual_price_at_signal=data.get("actual_price_at_signal"),
            outcome_price=data.get("outcome_price"),
            outcome_date=datetime.fromisoformat(data["outcome_date"]) if data.get("outcome_date") else None,
            outcome_return=data.get("outcome_return"),
            is_winner=data.get("is_winner"),
            locations_analyzed=data.get("locations_analyzed", 0),
            reviews_analyzed=data.get("reviews_analyzed", 0),
            sentiment_score=data.get("sentiment_score"),
            sentiment_change=data.get("sentiment_change"),
        )


class SignalLogger:
    """
    Signal Logger - Records all trading signals for track record
    
    Features:
    - Persistent storage (PostgreSQL)
    - Real-time logging
    - Outcome tracking
    - Compliance-ready audit trail
    """
    
    def __init__(self, db_url: Optional[str] = None, storage_path: str = "signals/"):
        self.db_url = db_url
        self.storage_path = storage_path
        self._signals: List[Signal] = []  # In-memory cache
        logger.info(f"SignalLogger initialized | DB: {db_url is not None} | Path: {storage_path}")
    
    def log_signal(
        self,
        symbol: str,
        signal_type: SignalType,
        confidence: float,
        brand: str = "",
        source: SignalSource = SignalSource.SENTIMENT_SPIKE,
        reasoning: str = "",
        source_data: Optional[Dict[str, Any]] = None,
        entry_price: Optional[float] = None,
        target_price: Optional[float] = None,
        stop_loss: Optional[float] = None,
        sentiment_score: Optional[float] = None,
        sentiment_change: Optional[float] = None,
        locations_analyzed: int = 0,
        reviews_analyzed: int = 0,
    ) -> Signal:
        """
        Log a new trading signal
        
        Args:
            symbol: Stock ticker symbol
            signal_type: BUY, SELL, HOLD, STRONG_BUY, STRONG_SELL
            confidence: Confidence score 0.0-1.0
            brand: Brand name
            source: Signal source type
            reasoning: Human-readable explanation
            source_data: Raw data that generated the signal
            entry_price: Recommended entry price
            target_price: Price target
            stop_loss: Stop loss level
            sentiment_score: Current sentiment score
            sentiment_change: Change in sentiment
            locations_analyzed: Number of locations in analysis
            reviews_analyzed: Number of reviews analyzed
            
        Returns:
            Signal object with generated ID
        """
        signal = Signal(
            symbol=symbol.upper(),
            brand=brand,
            signal_type=signal_type,
            confidence=min(max(confidence, 0.0), 1.0),  # Clamp to 0-1
            strength=self._calculate_strength(signal_type, confidence),
            source=source,
            reasoning=reasoning,
            source_data=source_data or {},
            entry_price=entry_price,
            target_price=target_price,
            stop_loss=stop_loss,
            sentiment_score=sentiment_score,
            sentiment_change=sentiment_change,
            locations_analyzed=locations_analyzed,
            reviews_analyzed=reviews_analyzed,
            valid_until=self._calculate_validity(signal_type),
        )
        
        # Store signal
        self._signals.append(signal)
        self._persist_signal(signal)
        
        logger.info(
            f"Signal logged: {signal.id[:8]} | "
            f"{signal.symbol} | {signal.signal_type.value} | "
            f"Confidence: {signal.confidence:.2%}"
        )
        
        return signal
    
    def _calculate_strength(self, signal_type: SignalType, confidence: float) -> float:
        """Calculate signal strength multiplier"""
        base_strength = {
            SignalType.STRONG_BUY: 2.0,
            SignalType.BUY: 1.0,
            SignalType.HOLD: 0.0,
            SignalType.SELL: -1.0,
            SignalType.STRONG_SELL: -2.0,
        }
        return base_strength.get(signal_type, 0.0) * confidence
    
    def _calculate_validity(self, signal_type: SignalType) -> datetime:
        """Calculate signal validity period"""
        from datetime import timedelta
        
        # Strong signals valid for shorter period
        validity_days = {
            SignalType.STRONG_BUY: 3,
            SignalType.BUY: 7,
            SignalType.HOLD: 14,
            SignalType.SELL: 7,
            SignalType.STRONG_SELL: 3,
        }
        days = validity_days.get(signal_type, 7)
        return datetime.now(timezone.utc) + timedelta(days=days)
    
    def _persist_signal(self, signal: Signal) -> None:
        """Persist signal to storage"""
        import os
        
        # Create directory if needed
        os.makedirs(self.storage_path, exist_ok=True)
        
        # Save to JSON file (one per day)
        date_str = signal.generated_at.strftime("%Y-%m-%d")
        filepath = os.path.join(self.storage_path, f"signals_{date_str}.jsonl")
        
        with open(filepath, "a") as f:
            f.write(json.dumps(signal.to_dict()) + "\n")
    
    def update_outcome(
        self,
        signal_id: str,
        outcome_price: float,
        outcome_date: Optional[datetime] = None,
    ) -> Optional[Signal]:
        """
        Update signal with actual outcome
        
        Args:
            signal_id: Signal ID to update
            outcome_price: Actual price at outcome
            outcome_date: Date of outcome measurement
            
        Returns:
            Updated Signal or None if not found
        """
        for signal in self._signals:
            if signal.id == signal_id:
                signal.outcome_price = outcome_price
                signal.outcome_date = outcome_date or datetime.now(timezone.utc)
                
                # Calculate return
                if signal.actual_price_at_signal:
                    if signal.signal_type in [SignalType.BUY, SignalType.STRONG_BUY]:
                        signal.outcome_return = (
                            (outcome_price - signal.actual_price_at_signal) 
                            / signal.actual_price_at_signal
                        )
                    else:  # SELL signals
                        signal.outcome_return = (
                            (signal.actual_price_at_signal - outcome_price) 
                            / signal.actual_price_at_signal
                        )
                    
                    signal.is_winner = signal.outcome_return > 0
                
                logger.info(
                    f"Outcome updated: {signal_id[:8]} | "
                    f"Return: {signal.outcome_return:.2%} | "
                    f"Winner: {signal.is_winner}"
                )
                return signal
        
        return None
    
    def get_signals(
        self,
        symbol: Optional[str] = None,
        signal_type: Optional[SignalType] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        min_confidence: float = 0.0,
    ) -> List[Signal]:
        """
        Query signals with filters
        
        Args:
            symbol: Filter by ticker symbol
            signal_type: Filter by signal type
            start_date: Filter by start date
            end_date: Filter by end date
            min_confidence: Minimum confidence threshold
            
        Returns:
            List of matching signals
        """
        results = self._signals.copy()
        
        if symbol:
            results = [s for s in results if s.symbol == symbol.upper()]
        
        if signal_type:
            results = [s for s in results if s.signal_type == signal_type]
        
        if start_date:
            results = [s for s in results if s.generated_at >= start_date]
        
        if end_date:
            results = [s for s in results if s.generated_at <= end_date]
        
        if min_confidence > 0:
            results = [s for s in results if s.confidence >= min_confidence]
        
        return results
    
    def get_stats(self) -> Dict[str, Any]:
        """Get summary statistics"""
        total = len(self._signals)
        if total == 0:
            return {"total_signals": 0}
        
        completed = [s for s in self._signals if s.outcome_return is not None]
        winners = [s for s in completed if s.is_winner]
        
        return {
            "total_signals": total,
            "completed_signals": len(completed),
            "win_rate": len(winners) / len(completed) if completed else 0,
            "avg_confidence": sum(s.confidence for s in self._signals) / total,
            "signals_by_type": {
                st.value: len([s for s in self._signals if s.signal_type == st])
                for st in SignalType
            },
        }
